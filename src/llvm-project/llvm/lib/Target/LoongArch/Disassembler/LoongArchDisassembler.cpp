//===- LoongArchDisassembler.cpp - Disassembler for LoongArch -----------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file is part of the LoongArch Disassembler.
//
//===----------------------------------------------------------------------===//

#include "MCTargetDesc/LoongArchMCTargetDesc.h"
#include "LoongArch.h"
#include "llvm/ADT/ArrayRef.h"
#include "llvm/MC/MCContext.h"
#include "llvm/MC/MCDisassembler/MCDisassembler.h"
#include "llvm/MC/MCFixedLenDisassembler.h"
#include "llvm/MC/MCInst.h"
#include "llvm/MC/MCRegisterInfo.h"
#include "llvm/MC/MCSubtargetInfo.h"
#include "llvm/Support/Compiler.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/MathExtras.h"
#include "llvm/Support/TargetRegistry.h"
#include "llvm/Support/raw_ostream.h"
#include <cassert>
#include <cstdint>

using namespace llvm;

#define DEBUG_TYPE "loongarch-disassembler"

using DecodeStatus = MCDisassembler::DecodeStatus;

namespace {

class LoongArchDisassembler : public MCDisassembler {

public:
  LoongArchDisassembler(const MCSubtargetInfo &STI, MCContext &Ctx)
      : MCDisassembler(STI, Ctx) {}

  bool isFP64() const { return STI.getFeatureBits()[LoongArch::FeatureFP64Bit]; }

  bool is64Bit() const { return STI.getFeatureBits()[LoongArch::Feature64Bit]; }

  DecodeStatus getInstruction(MCInst &Instr, uint64_t &Size,
                              ArrayRef<uint8_t> Bytes, uint64_t Address,
                              raw_ostream &CStream) const override;
};

} // end anonymous namespace

// Forward declare these because the autogenerated code will reference them.
// Definitions are further down.
static DecodeStatus DecodeGPR64RegisterClass(MCInst &Inst,
                                             unsigned RegNo,
                                             uint64_t Address,
                                             const void *Decoder);

static DecodeStatus DecodeGPR32RegisterClass(MCInst &Inst,
                                             unsigned RegNo,
                                             uint64_t Address,
                                             const void *Decoder);

static DecodeStatus DecodePtrRegisterClass(MCInst &Inst,
                                           unsigned Insn,
                                           uint64_t Address,
                                           const void *Decoder);

static DecodeStatus DecodeFGR64RegisterClass(MCInst &Inst,
                                             unsigned RegNo,
                                             uint64_t Address,
                                             const void *Decoder);

static DecodeStatus DecodeFGR32RegisterClass(MCInst &Inst,
                                             unsigned RegNo,
                                             uint64_t Address,
                                             const void *Decoder);

static DecodeStatus DecodeFCSRRegisterClass(MCInst &Inst,
                                            unsigned RegNo,
                                            uint64_t Address,
                                            const void *Decoder);

static DecodeStatus DecodeFCFRRegisterClass(MCInst &Inst,
                                            unsigned RegNo,
                                            uint64_t Address,
                                            const void *Decoder);

static DecodeStatus DecodeLSX128BRegisterClass(MCInst &Inst, unsigned RegNo,
                                               uint64_t Address,
                                               const void *Decoder);

static DecodeStatus DecodeLSX128HRegisterClass(MCInst &Inst, unsigned RegNo,
                                               uint64_t Address,
                                               const void *Decoder);

static DecodeStatus DecodeLSX128WRegisterClass(MCInst &Inst, unsigned RegNo,
                                               uint64_t Address,
                                               const void *Decoder);

static DecodeStatus DecodeLSX128DRegisterClass(MCInst &Inst, unsigned RegNo,
                                               uint64_t Address,
                                               const void *Decoder);

static DecodeStatus DecodeLASX256BRegisterClass(MCInst &Inst, unsigned RegNo,
                                                uint64_t Address,
                                                const void *Decoder);

static DecodeStatus DecodeLASX256HRegisterClass(MCInst &Inst, unsigned RegNo,
                                                uint64_t Address,
                                                const void *Decoder);

static DecodeStatus DecodeLASX256WRegisterClass(MCInst &Inst, unsigned RegNo,
                                                uint64_t Address,
                                                const void *Decoder);

static DecodeStatus DecodeLASX256DRegisterClass(MCInst &Inst, unsigned RegNo,
                                                uint64_t Address,
                                                const void *Decoder);

static DecodeStatus DecodeBranchTarget(MCInst &Inst,
                                       unsigned Offset,
                                       uint64_t Address,
                                       const void *Decoder);

static DecodeStatus DecodeJumpTarget(MCInst &Inst,
                                     unsigned Insn,
                                     uint64_t Address,
                                     const void *Decoder);

static DecodeStatus DecodeMem(MCInst &Inst,
                              unsigned Insn,
                              uint64_t Address,
                              const void *Decoder);

static DecodeStatus DecodeAMem(MCInst &Inst, unsigned Insn, uint64_t Address,
                               const void *Decoder);

static DecodeStatus DecodeMemSimm14(MCInst &Inst,
                                    unsigned Insn,
                                    uint64_t Address,
                                    const void *Decoder);

static DecodeStatus DecodeLSX128Mem(MCInst &Inst, unsigned Insn,
                                    uint64_t Address, const void *Decoder);

static DecodeStatus DecodeLSX128Mem13(MCInst &Inst, unsigned Insn,
                                      uint64_t Address, const void *Decoder);

static DecodeStatus DecodeLSX128Mem10(MCInst &Inst, unsigned Insn,
                                      uint64_t Address, const void *Decoder);

static DecodeStatus DecodeLASX256Mem13(MCInst &Inst, unsigned Insn,
                                       uint64_t Address, const void *Decoder);

static DecodeStatus DecodeLASX256Mem10(MCInst &Inst, unsigned Insn,
                                       uint64_t Address, const void *Decoder);

static DecodeStatus DecodeLSX128memlsl(MCInst &Inst, unsigned Insn,
                                       uint64_t Address, const void *Decoder);

static DecodeStatus DecodeLSX128memstl(MCInst &Inst, unsigned Insn,
                                       uint64_t Address, const void *Decoder);

static DecodeStatus DecodeLASX256memlsl(MCInst &Inst, unsigned Insn,
                                        uint64_t Address, const void *Decoder);

static DecodeStatus DecodeLASX256memstl(MCInst &Inst, unsigned Insn,
                                        uint64_t Address, const void *Decoder);

static DecodeStatus DecodeLASX256Mem(MCInst &Inst, unsigned Insn,
                                     uint64_t Address, const void *Decoder);

static DecodeStatus DecodeFMem(MCInst &Inst, unsigned Insn,
                               uint64_t Address,
                               const void *Decoder);

template <unsigned Bits, int Offset, int Scale>
static DecodeStatus DecodeUImmWithOffsetAndScale(MCInst &Inst, unsigned Value,
                                                 uint64_t Address,
                                                 const void *Decoder);

template <unsigned Bits, int Offset>
static DecodeStatus DecodeUImmWithOffset(MCInst &Inst, unsigned Value,
                                         uint64_t Address,
                                         const void *Decoder) {
  return DecodeUImmWithOffsetAndScale<Bits, Offset, 1>(Inst, Value, Address,
                                                       Decoder);
}

template <unsigned Bits, int Offset = 0, int ScaleBy = 1>
static DecodeStatus DecodeSImmWithOffsetAndScale(MCInst &Inst, unsigned Value,
                                                 uint64_t Address,
                                                 const void *Decoder);

/// INSVE_[BHWD] have an implicit operand that the generated decoder doesn't
/// handle.
template <typename InsnType>
static DecodeStatus DecodeINSVE_DF(MCInst &MI, InsnType insn, uint64_t Address,
                                   const void *Decoder);

namespace llvm {

Target &getTheLoongArch32Target();
Target &getTheLoongArch64Target();

} // end namespace llvm

static MCDisassembler *createLoongArchDisassembler(
                       const Target &T,
                       const MCSubtargetInfo &STI,
                       MCContext &Ctx) {
  return new LoongArchDisassembler(STI, Ctx);
}

extern "C" LLVM_EXTERNAL_VISIBILITY void LLVMInitializeLoongArchDisassembler() {
  // Register the disassembler.
  TargetRegistry::RegisterMCDisassembler(getTheLoongArch32Target(),
                                         createLoongArchDisassembler);
  TargetRegistry::RegisterMCDisassembler(getTheLoongArch64Target(),
                                         createLoongArchDisassembler);
}

#include "LoongArchGenDisassemblerTables.inc"

static unsigned getReg(const void *D, unsigned RC, unsigned RegNo) {
  const LoongArchDisassembler *Dis = static_cast<const LoongArchDisassembler*>(D);
  const MCRegisterInfo *RegInfo = Dis->getContext().getRegisterInfo();
  if (RC == LoongArch::GPR64RegClassID || RC == LoongArch::GPR32RegClassID) {
    // sync with the GPR32/GPR64 RegisterClass in LoongArchRegisterInfo.td
    // that just like LoongArchAsmParser.cpp and LoongArchISelLowering.cpp
    unsigned char indexes[] = { 0, 27, 28, 29, 1, 2, 3, 4,
                                5, 6, 7, 8, 9, 10, 11, 12,
                                13, 14, 15, 16, 17, 30, 31, 18,
                                19, 20, 21, 22, 23, 24, 25, 26
                              };
    assert(RegNo < sizeof(indexes));
    return *(RegInfo->getRegClass(RC).begin() + indexes[RegNo]);
  }
  return *(RegInfo->getRegClass(RC).begin() + RegNo);
}

template <typename InsnType>
static DecodeStatus DecodeINSVE_DF(MCInst &MI, InsnType insn, uint64_t Address,
                                   const void *Decoder) {
  using DecodeFN = DecodeStatus (*)(MCInst &, unsigned, uint64_t, const void *);

  // The size of the n field depends on the element size
  // The register class also depends on this.
  InsnType tmp = fieldFromInstruction(insn, 17, 5);
  unsigned NSize = 0;
  DecodeFN RegDecoder = nullptr;
  if ((tmp & 0x18) == 0x00) {
    NSize = 4;
    RegDecoder = DecodeLSX128BRegisterClass;
  } else if ((tmp & 0x1c) == 0x10) {
    NSize = 3;
    RegDecoder = DecodeLSX128HRegisterClass;
  } else if ((tmp & 0x1e) == 0x18) {
    NSize = 2;
    RegDecoder = DecodeLSX128WRegisterClass;
  } else if ((tmp & 0x1f) == 0x1c) {
    NSize = 1;
    RegDecoder = DecodeLSX128DRegisterClass;
  } else
    llvm_unreachable("Invalid encoding");

  assert(NSize != 0 && RegDecoder != nullptr);

  // $vd
  tmp = fieldFromInstruction(insn, 6, 5);
  if (RegDecoder(MI, tmp, Address, Decoder) == MCDisassembler::Fail)
    return MCDisassembler::Fail;
  // $vd_in
  if (RegDecoder(MI, tmp, Address, Decoder) == MCDisassembler::Fail)
    return MCDisassembler::Fail;
  // $n
  tmp = fieldFromInstruction(insn, 16, NSize);
  MI.addOperand(MCOperand::createImm(tmp));
  // $vs
  tmp = fieldFromInstruction(insn, 11, 5);
  if (RegDecoder(MI, tmp, Address, Decoder) == MCDisassembler::Fail)
    return MCDisassembler::Fail;
  // $n2
  MI.addOperand(MCOperand::createImm(0));

  return MCDisassembler::Success;
}

/// Read four bytes from the ArrayRef and return 32 bit word.
static DecodeStatus readInstruction32(ArrayRef<uint8_t> Bytes, uint64_t Address,
                                      uint64_t &Size, uint32_t &Insn) {
  // We want to read exactly 4 Bytes of data.
  if (Bytes.size() < 4) {
    Size = 0;
    return MCDisassembler::Fail;
  }

  Insn = (Bytes[0] << 0) | (Bytes[1] << 8) | (Bytes[2] << 16) |
         (Bytes[3] << 24);

  return MCDisassembler::Success;
}

DecodeStatus LoongArchDisassembler::getInstruction(MCInst &Instr, uint64_t &Size,
                                                   ArrayRef<uint8_t> Bytes,
                                                   uint64_t Address,
                                                   raw_ostream &CStream) const {
  uint32_t Insn;
  DecodeStatus Result;
  Size = 0;

  // Attempt to read the instruction so that we can attempt to decode it. If
  // the buffer is not 4 bytes long, let the higher level logic figure out
  // what to do with a size of zero and MCDisassembler::Fail.
  Result = readInstruction32(Bytes, Address, Size, Insn);
  if (Result == MCDisassembler::Fail)
    return MCDisassembler::Fail;

  // The only instruction size for standard encoded LoongArch.
  Size = 4;

  if (is64Bit()) {
    LLVM_DEBUG(dbgs() << "Trying LoongArch (GPR64) table (32-bit opcodes):\n");
    Result = decodeInstruction(DecoderTableLoongArch32, Instr, Insn,
                               Address, this, STI);
    if (Result != MCDisassembler::Fail)
      return Result;
  }

  LLVM_DEBUG(dbgs() << "Trying LoongArch32 (GPR32) table (32-bit opcodes):\n");
  Result = decodeInstruction(DecoderTableLoongArch3232, Instr, Insn,
                             Address, this, STI);
  if (Result != MCDisassembler::Fail)
    return Result;

  return MCDisassembler::Fail;
}

static DecodeStatus DecodeGPR64RegisterClass(MCInst &Inst,
                                             unsigned RegNo,
                                             uint64_t Address,
                                             const void *Decoder) {
  if (RegNo > 31)
    return MCDisassembler::Fail;

  unsigned Reg = getReg(Decoder, LoongArch::GPR64RegClassID, RegNo);
  Inst.addOperand(MCOperand::createReg(Reg));
  return MCDisassembler::Success;
}

static DecodeStatus DecodeGPR32RegisterClass(MCInst &Inst,
                                             unsigned RegNo,
                                             uint64_t Address,
                                             const void *Decoder) {
  if (RegNo > 31)
    return MCDisassembler::Fail;
  unsigned Reg = getReg(Decoder, LoongArch::GPR32RegClassID, RegNo);
  Inst.addOperand(MCOperand::createReg(Reg));
  return MCDisassembler::Success;
}

static DecodeStatus DecodePtrRegisterClass(MCInst &Inst,
                                           unsigned RegNo,
                                           uint64_t Address,
                                           const void *Decoder) {
  if (static_cast<const LoongArchDisassembler *>(Decoder)->is64Bit())
    return DecodeGPR64RegisterClass(Inst, RegNo, Address, Decoder);

  return DecodeGPR32RegisterClass(Inst, RegNo, Address, Decoder);
}

static DecodeStatus DecodeFGR64RegisterClass(MCInst &Inst,
                                             unsigned RegNo,
                                             uint64_t Address,
                                             const void *Decoder) {
  if (RegNo > 31)
    return MCDisassembler::Fail;
  unsigned Reg = getReg(Decoder, LoongArch::FGR64RegClassID, RegNo);
  Inst.addOperand(MCOperand::createReg(Reg));
  return MCDisassembler::Success;
}

static DecodeStatus DecodeFGR32RegisterClass(MCInst &Inst,
                                             unsigned RegNo,
                                             uint64_t Address,
                                             const void *Decoder) {
  if (RegNo > 31)
    return MCDisassembler::Fail;

  unsigned Reg = getReg(Decoder, LoongArch::FGR32RegClassID, RegNo);
  Inst.addOperand(MCOperand::createReg(Reg));
  return MCDisassembler::Success;
}

static DecodeStatus DecodeFCSRRegisterClass(MCInst &Inst,
                                            unsigned RegNo,
                                            uint64_t Address,
                                            const void *Decoder) {
  if (RegNo > 31)
    return MCDisassembler::Fail;

  unsigned Reg = getReg(Decoder, LoongArch::FCSRRegClassID, RegNo);
  Inst.addOperand(MCOperand::createReg(Reg));
  return MCDisassembler::Success;
}

static DecodeStatus DecodeFCFRRegisterClass(MCInst &Inst,
                                            unsigned RegNo,
                                            uint64_t Address,
                                            const void *Decoder) {
  if (RegNo > 7)
    return MCDisassembler::Fail;

  unsigned Reg = getReg(Decoder, LoongArch::FCFRRegClassID, RegNo);
  Inst.addOperand(MCOperand::createReg(Reg));

  return MCDisassembler::Success;
}

static DecodeStatus DecodeMem(MCInst &Inst,
                              unsigned Insn,
                              uint64_t Address,
                              const void *Decoder) {
  int Offset = SignExtend32<12>((Insn >> 10) & 0xfff);
  unsigned Reg = fieldFromInstruction(Insn, 0, 5);
  unsigned Base = fieldFromInstruction(Insn, 5, 5);

  Reg = getReg(Decoder, LoongArch::GPR32RegClassID, Reg);
  Base = getReg(Decoder, LoongArch::GPR32RegClassID, Base);

  if (Inst.getOpcode() == LoongArch::SC_W ||
      Inst.getOpcode() == LoongArch::SC_D)
    Inst.addOperand(MCOperand::createReg(Reg));

  Inst.addOperand(MCOperand::createReg(Reg));
  Inst.addOperand(MCOperand::createReg(Base));
  Inst.addOperand(MCOperand::createImm(Offset));

  return MCDisassembler::Success;
}

static DecodeStatus DecodeAMem(MCInst &Inst, unsigned Insn, uint64_t Address,
                               const void *Decoder) {
  unsigned Rd = fieldFromInstruction(Insn, 0, 5);
  unsigned Rj = fieldFromInstruction(Insn, 5, 5);
  unsigned Rk = fieldFromInstruction(Insn, 10, 5);

  Rd = getReg(Decoder, LoongArch::GPR32RegClassID, Rd);
  Rj = getReg(Decoder, LoongArch::GPR32RegClassID, Rj);
  Rk = getReg(Decoder, LoongArch::GPR32RegClassID, Rk);

  // Note the operands sequence is "rd,rk,rj".
  Inst.addOperand(MCOperand::createReg(Rd));
  Inst.addOperand(MCOperand::createReg(Rk));
  Inst.addOperand(MCOperand::createReg(Rj));

  return MCDisassembler::Success;
}

static DecodeStatus DecodeMemSimm14(MCInst &Inst,
                                    unsigned Insn,
                                    uint64_t Address,
                                    const void *Decoder) {
  int Offset = SignExtend32<12>((Insn >> 10) & 0x3fff);
  unsigned Reg = fieldFromInstruction(Insn, 0, 5);
  unsigned Base = fieldFromInstruction(Insn, 5, 5);

  Reg = getReg(Decoder, LoongArch::GPR32RegClassID, Reg);
  Base = getReg(Decoder, LoongArch::GPR32RegClassID, Base);

  if (Inst.getOpcode() == LoongArch::SC_W ||
      Inst.getOpcode() == LoongArch::SC_D)
    Inst.addOperand(MCOperand::createReg(Reg));

  Inst.addOperand(MCOperand::createReg(Reg));
  Inst.addOperand(MCOperand::createReg(Base));
  Inst.addOperand(MCOperand::createImm(Offset));

  return MCDisassembler::Success;
}

static DecodeStatus DecodeLSX128Mem(MCInst &Inst, unsigned Insn,
                                    uint64_t Address, const void *Decoder) {
  int Offset = SignExtend32<12>(fieldFromInstruction(Insn, 10, 12));
  unsigned Reg = fieldFromInstruction(Insn, 0, 5);
  unsigned Base = fieldFromInstruction(Insn, 5, 5);
  Reg = getReg(Decoder, LoongArch::LSX128BRegClassID, Reg);
  Base = getReg(Decoder, LoongArch::GPR32RegClassID, Base);

  Inst.addOperand(MCOperand::createReg(Reg));
  Inst.addOperand(MCOperand::createReg(Base));

  Inst.addOperand(MCOperand::createImm(Offset));

  return MCDisassembler::Success;
}

static DecodeStatus DecodeLSX128Mem13(MCInst &Inst, unsigned Insn,
                                      uint64_t Address, const void *Decoder) {
  int Offset = SignExtend32<13>(fieldFromInstruction(Insn, 5, 13));
  unsigned Reg = fieldFromInstruction(Insn, 0, 5);
  Reg = getReg(Decoder, LoongArch::LSX128BRegClassID, Reg);

  Inst.addOperand(MCOperand::createReg(Reg));

  Inst.addOperand(MCOperand::createImm(Offset));

  return MCDisassembler::Success;
}

static DecodeStatus DecodeLSX128Mem10(MCInst &Inst, unsigned Insn,
                                      uint64_t Address, const void *Decoder) {
  int Offset = SignExtend32<10>(fieldFromInstruction(Insn, 5, 10));
  unsigned Reg = fieldFromInstruction(Insn, 0, 5);
  Reg = getReg(Decoder, LoongArch::LSX128BRegClassID, Reg);

  Inst.addOperand(MCOperand::createReg(Reg));

  Inst.addOperand(MCOperand::createImm(Offset));

  return MCDisassembler::Success;
}

static DecodeStatus DecodeLASX256Mem13(MCInst &Inst, unsigned Insn,
                                       uint64_t Address, const void *Decoder) {
  int Offset = SignExtend32<13>(fieldFromInstruction(Insn, 5, 13));
  unsigned Reg = fieldFromInstruction(Insn, 0, 5);
  Reg = getReg(Decoder, LoongArch::LASX256BRegClassID, Reg);

  Inst.addOperand(MCOperand::createReg(Reg));

  Inst.addOperand(MCOperand::createImm(Offset));

  return MCDisassembler::Success;
}

static DecodeStatus DecodeLASX256Mem10(MCInst &Inst, unsigned Insn,
                                       uint64_t Address, const void *Decoder) {
  int Offset = SignExtend32<10>(fieldFromInstruction(Insn, 5, 10));
  unsigned Reg = fieldFromInstruction(Insn, 0, 5);
  Reg = getReg(Decoder, LoongArch::LASX256BRegClassID, Reg);

  Inst.addOperand(MCOperand::createReg(Reg));

  Inst.addOperand(MCOperand::createImm(Offset));

  return MCDisassembler::Success;
}

static DecodeStatus DecodeLSX128memstl(MCInst &Inst, unsigned Insn,
                                       uint64_t Address, const void *Decoder) {
  int Offset = SignExtend32<8>(fieldFromInstruction(Insn, 10, 8));
  unsigned Reg = fieldFromInstruction(Insn, 0, 5);
  unsigned Base = fieldFromInstruction(Insn, 5, 5);
  Reg = getReg(Decoder, LoongArch::LSX128BRegClassID, Reg);
  Base = getReg(Decoder, LoongArch::GPR32RegClassID, Base);
  unsigned idx;

  Inst.addOperand(MCOperand::createReg(Reg));
  Inst.addOperand(MCOperand::createReg(Base));

  switch (Inst.getOpcode()) {
  default:
    assert(false && "Unexpected instruction");
    return MCDisassembler::Fail;
    break;
  case LoongArch::VSTELM_B:
    Inst.addOperand(MCOperand::createImm(Offset));
    idx = fieldFromInstruction(Insn, 18, 4);
    Inst.addOperand(MCOperand::createImm(idx));
    break;
  case LoongArch::VSTELM_H:
    Inst.addOperand(MCOperand::createImm(Offset * 2));
    idx = fieldFromInstruction(Insn, 18, 3);
    Inst.addOperand(MCOperand::createImm(idx));
    break;
  case LoongArch::VSTELM_W:
    Inst.addOperand(MCOperand::createImm(Offset * 4));
    idx = fieldFromInstruction(Insn, 18, 2);
    Inst.addOperand(MCOperand::createImm(idx));
    break;
  case LoongArch::VSTELM_D:
    Inst.addOperand(MCOperand::createImm(Offset * 8));
    idx = fieldFromInstruction(Insn, 18, 1);
    Inst.addOperand(MCOperand::createImm(idx));
    break;
  }

  return MCDisassembler::Success;
}

static DecodeStatus DecodeLSX128memlsl(MCInst &Inst, unsigned Insn,
                                       uint64_t Address, const void *Decoder) {

  int Offset;
  unsigned Reg, Base;
  switch (Inst.getOpcode()) {
  default:
    assert(false && "Unexpected instruction");
    return MCDisassembler::Fail;
    break;
  case LoongArch::VLDREPL_B:

    Offset = SignExtend32<12>(fieldFromInstruction(Insn, 10, 12));
    Reg = fieldFromInstruction(Insn, 0, 5);
    Base = fieldFromInstruction(Insn, 5, 5);
    Reg = getReg(Decoder, LoongArch::LSX128BRegClassID, Reg);
    Base = getReg(Decoder, LoongArch::GPR32RegClassID, Base);

    Inst.addOperand(MCOperand::createReg(Reg));
    Inst.addOperand(MCOperand::createReg(Base));

    Inst.addOperand(MCOperand::createImm(Offset));
    break;
  case LoongArch::VLDREPL_H:

    Offset = SignExtend32<11>(fieldFromInstruction(Insn, 10, 11));
    Reg = fieldFromInstruction(Insn, 0, 5);
    Base = fieldFromInstruction(Insn, 5, 5);
    Reg = getReg(Decoder, LoongArch::LSX128HRegClassID, Reg);
    Base = getReg(Decoder, LoongArch::GPR32RegClassID, Base);

    Inst.addOperand(MCOperand::createReg(Reg));
    Inst.addOperand(MCOperand::createReg(Base));
    Inst.addOperand(MCOperand::createImm(Offset * 2));
    break;
  case LoongArch::VLDREPL_W:

    Offset = SignExtend32<10>(fieldFromInstruction(Insn, 10, 10));
    Reg = fieldFromInstruction(Insn, 0, 5);
    Base = fieldFromInstruction(Insn, 5, 5);
    Reg = getReg(Decoder, LoongArch::LSX128WRegClassID, Reg);
    Base = getReg(Decoder, LoongArch::GPR32RegClassID, Base);

    Inst.addOperand(MCOperand::createReg(Reg));
    Inst.addOperand(MCOperand::createReg(Base));
    Inst.addOperand(MCOperand::createImm(Offset * 4));
    break;
  case LoongArch::VLDREPL_D:

    Offset = SignExtend32<9>(fieldFromInstruction(Insn, 10, 9));
    Reg = fieldFromInstruction(Insn, 0, 5);
    Base = fieldFromInstruction(Insn, 5, 5);
    Reg = getReg(Decoder, LoongArch::LSX128WRegClassID, Reg);
    Base = getReg(Decoder, LoongArch::GPR32RegClassID, Base);

    Inst.addOperand(MCOperand::createReg(Reg));
    Inst.addOperand(MCOperand::createReg(Base));
    Inst.addOperand(MCOperand::createImm(Offset * 8));
    break;
  }

  return MCDisassembler::Success;
}
static DecodeStatus DecodeLASX256Mem(MCInst &Inst, unsigned Insn,
                                     uint64_t Address, const void *Decoder) {
  int Offset = SignExtend32<12>(fieldFromInstruction(Insn, 10, 12));
  unsigned Reg = fieldFromInstruction(Insn, 0, 5);
  unsigned Base = fieldFromInstruction(Insn, 5, 5);
  Reg = getReg(Decoder, LoongArch::LASX256BRegClassID, Reg);
  Base = getReg(Decoder, LoongArch::GPR32RegClassID, Base);

  Inst.addOperand(MCOperand::createReg(Reg));
  Inst.addOperand(MCOperand::createReg(Base));

  Inst.addOperand(MCOperand::createImm(Offset));

  return MCDisassembler::Success;
}

static DecodeStatus DecodeLASX256memstl(MCInst &Inst, unsigned Insn,
                                        uint64_t Address, const void *Decoder) {
  int Offset = SignExtend32<8>(fieldFromInstruction(Insn, 10, 8));
  unsigned Reg = fieldFromInstruction(Insn, 0, 5);
  unsigned Base = fieldFromInstruction(Insn, 5, 5);
  Reg = getReg(Decoder, LoongArch::LASX256BRegClassID, Reg);
  Base = getReg(Decoder, LoongArch::GPR32RegClassID, Base);
  unsigned idx;

  Inst.addOperand(MCOperand::createReg(Reg));
  Inst.addOperand(MCOperand::createReg(Base));

  switch (Inst.getOpcode()) {
  default:
    assert(false && "Unexpected instruction");
    return MCDisassembler::Fail;
    break;
  case LoongArch::XVSTELM_B:
    Inst.addOperand(MCOperand::createImm(Offset));
    idx = fieldFromInstruction(Insn, 18, 5);
    Inst.addOperand(MCOperand::createImm(idx));
    break;
  case LoongArch::XVSTELM_H:
    Inst.addOperand(MCOperand::createImm(Offset * 2));
    idx = fieldFromInstruction(Insn, 18, 4);
    Inst.addOperand(MCOperand::createImm(idx));
    break;
  case LoongArch::XVSTELM_W:
    Inst.addOperand(MCOperand::createImm(Offset * 4));
    idx = fieldFromInstruction(Insn, 18, 3);
    Inst.addOperand(MCOperand::createImm(idx));
    break;
  case LoongArch::XVSTELM_D:
    Inst.addOperand(MCOperand::createImm(Offset * 8));
    idx = fieldFromInstruction(Insn, 18, 2);
    Inst.addOperand(MCOperand::createImm(idx));
    break;
  }

  return MCDisassembler::Success;
}

static DecodeStatus DecodeLASX256memlsl(MCInst &Inst, unsigned Insn,
                                        uint64_t Address, const void *Decoder) {

  int Offset;
  unsigned Reg, Base;
  switch (Inst.getOpcode()) {
  default:
    assert(false && "Unexpected instruction");
    return MCDisassembler::Fail;
    break;
  case LoongArch::XVLDREPL_B:

    Offset = SignExtend32<12>(fieldFromInstruction(Insn, 10, 12));
    Reg = fieldFromInstruction(Insn, 0, 5);
    Base = fieldFromInstruction(Insn, 5, 5);
    Reg = getReg(Decoder, LoongArch::LASX256BRegClassID, Reg);
    Base = getReg(Decoder, LoongArch::GPR32RegClassID, Base);

    Inst.addOperand(MCOperand::createReg(Reg));
    Inst.addOperand(MCOperand::createReg(Base));

    Inst.addOperand(MCOperand::createImm(Offset));
    break;
  case LoongArch::XVLDREPL_H:

    Offset = SignExtend32<11>(fieldFromInstruction(Insn, 10, 11));
    Reg = fieldFromInstruction(Insn, 0, 5);
    Base = fieldFromInstruction(Insn, 5, 5);
    Reg = getReg(Decoder, LoongArch::LASX256HRegClassID, Reg);
    Base = getReg(Decoder, LoongArch::GPR32RegClassID, Base);

    Inst.addOperand(MCOperand::createReg(Reg));
    Inst.addOperand(MCOperand::createReg(Base));
    Inst.addOperand(MCOperand::createImm(Offset * 2));
    break;
  case LoongArch::XVLDREPL_W:

    Offset = SignExtend32<10>(fieldFromInstruction(Insn, 10, 10));
    Reg = fieldFromInstruction(Insn, 0, 5);
    Base = fieldFromInstruction(Insn, 5, 5);
    Reg = getReg(Decoder, LoongArch::LASX256WRegClassID, Reg);
    Base = getReg(Decoder, LoongArch::GPR32RegClassID, Base);

    Inst.addOperand(MCOperand::createReg(Reg));
    Inst.addOperand(MCOperand::createReg(Base));
    Inst.addOperand(MCOperand::createImm(Offset * 4));
    break;
  case LoongArch::XVLDREPL_D:

    Offset = SignExtend32<9>(fieldFromInstruction(Insn, 10, 9));
    Reg = fieldFromInstruction(Insn, 0, 5);
    Base = fieldFromInstruction(Insn, 5, 5);
    Reg = getReg(Decoder, LoongArch::LASX256WRegClassID, Reg);
    Base = getReg(Decoder, LoongArch::GPR32RegClassID, Base);

    Inst.addOperand(MCOperand::createReg(Reg));
    Inst.addOperand(MCOperand::createReg(Base));
    Inst.addOperand(MCOperand::createImm(Offset * 8));
    break;
  }

  return MCDisassembler::Success;
}

static DecodeStatus DecodeFMem(MCInst &Inst,
                               unsigned Insn,
                               uint64_t Address,
                               const void *Decoder) {
  int Offset = SignExtend32<12>((Insn >> 10) & 0xffff);
  unsigned Reg = fieldFromInstruction(Insn, 0, 5);
  unsigned Base = fieldFromInstruction(Insn, 5, 5);
  Reg = getReg(Decoder, LoongArch::FGR64RegClassID, Reg);
  Base = getReg(Decoder, LoongArch::GPR32RegClassID, Base);

  Inst.addOperand(MCOperand::createReg(Reg));
  Inst.addOperand(MCOperand::createReg(Base));
  Inst.addOperand(MCOperand::createImm(Offset));

  return MCDisassembler::Success;
}

static DecodeStatus DecodeLSX128BRegisterClass(MCInst &Inst, unsigned RegNo,
                                               uint64_t Address,
                                               const void *Decoder) {
  if (RegNo > 31)
    return MCDisassembler::Fail;
  unsigned Reg = getReg(Decoder, LoongArch::LSX128BRegClassID, RegNo);
  Inst.addOperand(MCOperand::createReg(Reg));
  return MCDisassembler::Success;
}

static DecodeStatus DecodeLSX128HRegisterClass(MCInst &Inst, unsigned RegNo,
                                               uint64_t Address,
                                               const void *Decoder) {
  if (RegNo > 31)
    return MCDisassembler::Fail;
  unsigned Reg = getReg(Decoder, LoongArch::LSX128HRegClassID, RegNo);
  Inst.addOperand(MCOperand::createReg(Reg));
  return MCDisassembler::Success;
}

static DecodeStatus DecodeLSX128WRegisterClass(MCInst &Inst, unsigned RegNo,
                                               uint64_t Address,
                                               const void *Decoder) {
  if (RegNo > 31)
    return MCDisassembler::Fail;
  unsigned Reg = getReg(Decoder, LoongArch::LSX128WRegClassID, RegNo);
  Inst.addOperand(MCOperand::createReg(Reg));
  return MCDisassembler::Success;
}

static DecodeStatus DecodeLSX128DRegisterClass(MCInst &Inst, unsigned RegNo,
                                               uint64_t Address,
                                               const void *Decoder) {
  if (RegNo > 31)
    return MCDisassembler::Fail;
  unsigned Reg = getReg(Decoder, LoongArch::LSX128DRegClassID, RegNo);
  Inst.addOperand(MCOperand::createReg(Reg));
  return MCDisassembler::Success;
}

static DecodeStatus DecodeLASX256BRegisterClass(MCInst &Inst, unsigned RegNo,
                                                uint64_t Address,
                                                const void *Decoder) {
  if (RegNo > 31)
    return MCDisassembler::Fail;
  unsigned Reg = getReg(Decoder, LoongArch::LASX256BRegClassID, RegNo);
  Inst.addOperand(MCOperand::createReg(Reg));
  return MCDisassembler::Success;
}

static DecodeStatus DecodeLASX256HRegisterClass(MCInst &Inst, unsigned RegNo,
                                                uint64_t Address,
                                                const void *Decoder) {
  if (RegNo > 31)
    return MCDisassembler::Fail;
  unsigned Reg = getReg(Decoder, LoongArch::LASX256HRegClassID, RegNo);
  Inst.addOperand(MCOperand::createReg(Reg));
  return MCDisassembler::Success;
}

static DecodeStatus DecodeLASX256WRegisterClass(MCInst &Inst, unsigned RegNo,
                                                uint64_t Address,
                                                const void *Decoder) {
  if (RegNo > 31)
    return MCDisassembler::Fail;
  unsigned Reg = getReg(Decoder, LoongArch::LASX256WRegClassID, RegNo);
  Inst.addOperand(MCOperand::createReg(Reg));
  return MCDisassembler::Success;
}

static DecodeStatus DecodeLASX256DRegisterClass(MCInst &Inst, unsigned RegNo,
                                                uint64_t Address,
                                                const void *Decoder) {
  if (RegNo > 31)
    return MCDisassembler::Fail;
  unsigned Reg = getReg(Decoder, LoongArch::LASX256DRegClassID, RegNo);
  Inst.addOperand(MCOperand::createReg(Reg));
  return MCDisassembler::Success;
}

static DecodeStatus DecodeBranchTarget(MCInst &Inst,
                                       unsigned Offset,
                                       uint64_t Address,
                                       const void *Decoder) {
  int32_t BranchOffset;
  // Similar to LoongArchAsmParser::processInstruction, decode the branch target
  // for different instructions.
  switch (Inst.getOpcode()) {
  default:
    llvm_unreachable("");
  case LoongArch::BEQ:
  case LoongArch::BNE:
  case LoongArch::BLT:
  case LoongArch::BGE:
  case LoongArch::BLTU:
  case LoongArch::BGEU:
    BranchOffset = (SignExtend32<16>(Offset) * 4);
    break;
  case LoongArch::BEQZ:
  case LoongArch::BNEZ:
  case LoongArch::BCEQZ:
  case LoongArch::BCNEZ:
    BranchOffset = (SignExtend32<21>(Offset) * 4);
    break;
  case LoongArch::B:
  case LoongArch::BL:
    BranchOffset = (SignExtend32<26>(Offset) * 4);
    break;
  }
  Inst.addOperand(MCOperand::createImm(BranchOffset));
  return MCDisassembler::Success;
}

static DecodeStatus DecodeJumpTarget(MCInst &Inst,
                                     unsigned Insn,
                                     uint64_t Address,
                                     const void *Decoder) {
  unsigned hi10 = fieldFromInstruction(Insn, 0, 10);
  unsigned lo16 = fieldFromInstruction(Insn, 10, 16);
  int32_t JumpOffset = SignExtend32<28>((hi10 << 16 | lo16) << 2);
  Inst.addOperand(MCOperand::createImm(JumpOffset));
  return MCDisassembler::Success;
}

template <unsigned Bits, int Offset, int Scale>
static DecodeStatus DecodeUImmWithOffsetAndScale(MCInst &Inst, unsigned Value,
                                                 uint64_t Address,
                                                 const void *Decoder) {
  Value &= ((1 << Bits) - 1);
  Value *= Scale;
  Inst.addOperand(MCOperand::createImm(Value + Offset));
  return MCDisassembler::Success;
}

template <unsigned Bits, int Offset, int ScaleBy>
static DecodeStatus DecodeSImmWithOffsetAndScale(MCInst &Inst, unsigned Value,
                                                 uint64_t Address,
                                                 const void *Decoder) {
  int32_t Imm = SignExtend32<Bits>(Value) * ScaleBy;
  Inst.addOperand(MCOperand::createImm(Imm + Offset));
  return MCDisassembler::Success;
}
